<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      background-color: rgba(0, 0, 0, 0) !important;
      background: transparent !important;
      overflow: hidden;
      font-family: 'M PLUS Rounded 1c', 'Noto Sans JP', 'Yu Gothic UI', sans-serif;
    }

    #character {
      position: fixed;
      bottom: 0;
      right: 0;
      height: 50vh;
      z-index: 200;
    }

    #character img {
      position: absolute;
      bottom: 0;
      right: 0;
      height: 100%;
      width: auto;
    }

    #subtitle {
      position: fixed;
      bottom: 52vh;
      right: 2vw;
      max-width: 30vw;
      padding: 12px 24px;
      background: rgba(10, 15, 30, 0.9);
      color: #7eeda9;
      font-size: clamp(14px, 1.3vw, 28px);
      font-weight: bold;
      border-radius: 14px;
      border: 2px solid rgba(126, 237, 169, 0.3);
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8);
      line-height: 1.4;
      z-index: 210;
    }

    #subtitle.visible {
      opacity: 1;
    }

    #name {
      color: #ffd700;
      font-size: clamp(16px, 1.5vw, 34px);
      margin-bottom: 2px;
    }

    #status {
      display: none;
    }

    #activity {
      position: fixed;
      bottom: 48vh;
      right: 9.5vw;
      transform: translateX(50%);
      padding: 5px 12px;
      background: rgba(10, 15, 30, 0.92);
      color: #7eeda9;
      font-size: clamp(10px, 0.9vw, 16px);
      font-weight: bold;
      border-radius: 8px;
      border-left: 3px solid #7eeda9;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 210;
      white-space: nowrap;
    }

    #activity.visible {
      opacity: 1;
    }

    #activity .dot {
      display: inline-block;
      animation: blink 1.4s infinite;
    }

    #activity .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    #activity .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes blink {

      0%,
      20% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      100% {
        opacity: 0;
      }
    }

    /* --- mic-queue --- */
    #mic-queue {
      position: fixed;
      bottom: 1.5vh;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      max-width: 50vw;
      z-index: 210;
      pointer-events: none;
    }

    .mic-entry {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 18px;
      background: rgba(10, 15, 30, 0.92);
      color: #e8f0ff;
      font-size: clamp(14px, 1.3vw, 26px);
      font-weight: bold;
      border-radius: 10px;
      border-left: 4px solid #5eb5f7;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
      animation: mic-slide-in 0.3s ease-out forwards;
      white-space: pre-wrap;
      word-break: break-word;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .mic-entry .mic-icon {
      flex-shrink: 0;
      font-size: 0.7em;
      background: #5eb5f7;
      color: #0a0f1e;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: bold;
      letter-spacing: 1px;
    }

    .mic-entry .mic-status {
      flex-shrink: 0;
      font-size: 0.65em;
      margin-left: auto;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
    }

    .mic-entry .mic-status.unread {
      color: #ff6b6b;
    }

    .mic-entry .mic-status.read {
      color: #5eb5f7;
    }

    .mic-entry.processed {
      animation: mic-slide-out 0.5s ease-in forwards;
    }

    @keyframes mic-slide-in {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes mic-slide-out {
      from {
        opacity: 1;
        transform: translateX(0);
      }

      to {
        opacity: 0;
        transform: translateX(60px);
      }
    }

    #dynamic-content {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 16;
    }

    #dynamic-content>* {
      pointer-events: auto;
    }
  </style>
</head>

<body>
  <div id="character">
    <img id="sprite-base" src="sprites/base.png" alt="">
    <img id="sprite-mouth" src="sprites/mouth_closed.png" alt="">
  </div>
  <div id="subtitle">
    <div id="text"></div>
  </div>
  <div id="activity"></div>
  <div id="mic-queue"></div>
  <div id="dynamic-content"></div>
  <div id="status">Loading...</div>

  <script>
    // innerHTML で挿入された script タグを実行する
    function _execScripts(container) {
      container.querySelectorAll('script').forEach(oldScript => {
        const newScript = document.createElement('script');
        for (const attr of oldScript.attributes) {
          newScript.setAttribute(attr.name, attr.value);
        }
        newScript.textContent = oldScript.textContent;
        oldScript.parentNode.replaceChild(newScript, oldScript);
      });
    }

    const subtitleEl = document.getElementById('subtitle');
    const textEl = document.getElementById('text');
    const statusEl = document.getElementById('status');
    const mouthImg = document.getElementById('sprite-mouth');
    let hideTimer = null;
    let audioCtx = null;

    const MOUTH_OPEN_SRC = 'sprites/mouth_open.png';
    const MOUTH_HO_SRC = 'sprites/mouth_ho.png';
    const MOUTH_O_SRC = 'sprites/mouth_o.png';
    const MOUTH_CLOSED_SRC = 'sprites/mouth_closed.png';
    const MOUTH_CYCLE = [MOUTH_CLOSED_SRC, MOUTH_HO_SRC, MOUTH_O_SRC, MOUTH_OPEN_SRC];

    // 画像プリロード
    new Image().src = MOUTH_OPEN_SRC;
    new Image().src = MOUTH_HO_SRC;
    new Image().src = MOUTH_O_SRC;
    new Image().src = MOUTH_CLOSED_SRC;

    // --- スプライト初期化 ---
    function initSprite() {
      const baseImg = document.getElementById('sprite-base');
      if (baseImg.complete && baseImg.naturalWidth > 0) {
        statusEl.textContent = 'Sprite OK';
      } else {
        baseImg.onload = () => { statusEl.textContent = 'Sprite OK'; };
        baseImg.onerror = () => { statusEl.textContent = 'Sprite: image not found'; };
      }
    }

    // --- 口パク (タイマーベースで3段階サイクル) ---
    let lipSyncTimer = null;
    let mouthFrame = 0;

    function startLipSync(durationSec) {
      stopLipSync();
      mouthFrame = 0;
      function nextFrame() {
        // ランダムに口の形を選ぶ (ただし同じ形が連続しにくくする)
        let next;
        do {
          next = Math.floor(Math.random() * MOUTH_CYCLE.length);
        } while (next === mouthFrame && MOUTH_CYCLE.length > 1);
        mouthFrame = next;
        mouthImg.src = MOUTH_CYCLE[mouthFrame];
        const delay = 80 + Math.random() * 120;
        lipSyncTimer = setTimeout(nextFrame, delay);
      }
      nextFrame();
      // 音声の長さ分で自動停止
      if (durationSec > 0) {
        setTimeout(() => stopLipSync(), durationSec * 1000);
      }
    }

    function stopLipSync() {
      if (lipSyncTimer) {
        clearTimeout(lipSyncTimer);
        lipSyncTimer = null;
      }
      mouthFrame = 0;
      mouthImg.src = MOUTH_CLOSED_SRC;
    }

    async function doLipSync(audioUrl) {
      try {
        const res = await fetch(audioUrl);
        const buf = await res.arrayBuffer();
        // WAVヘッダーからサンプルレートとデータサイズを取得して再生時間を計算
        const view = new DataView(buf);
        const sampleRate = view.getUint32(24, true);
        const dataSize = view.getUint32(40, true);
        const channels = view.getUint16(22, true);
        const bitsPerSample = view.getUint16(34, true);
        const duration = dataSize / (sampleRate * channels * (bitsPerSample / 8));
        startLipSync(duration);
      } catch (e) {
        // フォールバック: 3秒間口パク
        console.warn('Lip sync audio fetch failed, using fallback:', e);
        startLipSync(3);
      }
    }

    // --- SSE 接続 (字幕 + 口パク) ---
    function connectSSE() {
      const es = new EventSource('/overlay/events');

      es.addEventListener('subtitle', (e) => {
        try {
          const data = JSON.parse(e.data);
          const text = data.text || '';
          if (text) {
            textEl.textContent = text;
            subtitleEl.classList.add('visible');
            clearTimeout(hideTimer);
          } else {
            hideTimer = setTimeout(() => subtitleEl.classList.remove('visible'), 500);
          }
        } catch (err) {
          if (e.data) {
            textEl.textContent = e.data;
            subtitleEl.classList.add('visible');
            clearTimeout(hideTimer);
          }
        }
      });

      es.addEventListener('speak', (e) => {
        const data = JSON.parse(e.data);
        if (data.audioUrl) {
          doLipSync(data.audioUrl);
        }
      });

      es.addEventListener('activity', (e) => {
        const data = JSON.parse(e.data);
        const activityEl = document.getElementById('activity');
        const text = data.text || '';
        if (text) {
          activityEl.innerHTML = text + ' <span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>';
          activityEl.classList.add('visible');
        } else {
          activityEl.classList.remove('visible');
        }
      });

      es.addEventListener('html', (e) => {
        const data = JSON.parse(e.data);
        const container = document.getElementById('dynamic-content');
        if (data.html !== undefined) {
          container.innerHTML = data.html;
          _execScripts(container);
        }
        if (data.css) {
          let styleEl = document.getElementById('dynamic-style');
          if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'dynamic-style';
            document.head.appendChild(styleEl);
          }
          styleEl.textContent = data.css;
        }
      });

      es.addEventListener('slot-update', (e) => {
        const data = JSON.parse(e.data);
        const slotName = data.slot;
        if (!slotName) return;
        const container = document.getElementById('dynamic-content');
        const slotId = 'slot-' + slotName;
        let slotEl = document.getElementById(slotId);
        if (!slotEl) {
          slotEl = document.createElement('div');
          slotEl.id = slotId;
          slotEl.className = 'overlay-slot';
          container.appendChild(slotEl);
        }
        slotEl.innerHTML = data.html || '';
        _execScripts(slotEl);
        // スロット固有CSS
        const styleId = 'slot-style-' + slotName;
        let styleEl = document.getElementById(styleId);
        if (data.css) {
          if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = styleId;
            document.head.appendChild(styleEl);
          }
          styleEl.textContent = data.css;
        } else if (styleEl) {
          styleEl.remove();
        }
      });

      es.addEventListener('slot-remove', (e) => {
        const data = JSON.parse(e.data);
        const slotName = data.slot;
        if (!slotName) return;
        const slotEl = document.getElementById('slot-' + slotName);
        if (slotEl) slotEl.remove();
        const styleEl = document.getElementById('slot-style-' + slotName);
        if (styleEl) styleEl.remove();
      });

      // --- mic-text: マイク入力テキストを画面に表示 ---
      es.addEventListener('mic-text', (e) => {
        const data = JSON.parse(e.data);
        if (data.id === undefined || data.text === undefined) return;
        const queue = document.getElementById('mic-queue');
        const entry = document.createElement('div');
        entry.className = 'mic-entry';
        entry.id = 'mic-' + data.id;
        entry.dataset.createdAt = String(Date.now());
        // テキストノードで安全に挿入
        const icon = document.createElement('span');
        icon.className = 'mic-icon';
        icon.textContent = 'MIC';
        const textSpan = document.createElement('span');
        textSpan.textContent = data.text;
        const status = document.createElement('span');
        status.className = 'mic-status unread';
        status.textContent = '\u672A\u8AAD';
        entry.appendChild(icon);
        entry.appendChild(textSpan);
        entry.appendChild(status);
        queue.appendChild(entry);
        // 古いエントリを4件まで保持
        while (queue.children.length > 3) {
          queue.removeChild(queue.firstChild);
        }
      });

      // --- mic-processed: 既読にして最低表示時間後にエフェクト付きで消す ---
      es.addEventListener('mic-processed', (e) => {
        const data = JSON.parse(e.data);
        if (data.id === undefined) return;
        const entry = document.getElementById('mic-' + data.id);
        if (entry) {
          // 未読→既読に変更
          const statusEl = entry.querySelector('.mic-status');
          if (statusEl) {
            statusEl.textContent = '\u65E2\u8AAD';
            statusEl.className = 'mic-status read';
          }
          const MIN_DISPLAY_MS = 5000;
          const createdAt = parseInt(entry.dataset.createdAt || '0', 10);
          const elapsed = Date.now() - createdAt;
          const remaining = Math.max(0, MIN_DISPLAY_MS - elapsed);
          setTimeout(() => {
            entry.classList.add('processed');
            entry.addEventListener('animationend', () => entry.remove(), { once: true });
          }, remaining);
        }
      });

      es.onerror = () => {
        es.close();
        statusEl.textContent = 'Reconnecting...';
        setTimeout(connectSSE, 2000);
      };

      es.onopen = () => {
        statusEl.textContent = 'Sprite OK';
      };
    }

    // --- 保存済みスロットの復元 ---
    async function restoreDynamicContent() {
      // スロットディレクトリからファイル一覧を取得して復元する
      // 既知のスロット名をサーバー API で取得する方法がないため、
      // slots/ ディレクトリの各ファイルを直接取得する
      try {
        const resp = await fetch('/api/overlay/slots?' + Date.now());
        if (resp.ok) {
          const slots = await resp.json();
          const container = document.getElementById('dynamic-content');
          for (const entry of slots) {
            const slotName = entry.slot;
            const slotId = 'slot-' + slotName;
            let slotEl = document.getElementById(slotId);
            if (!slotEl) {
              slotEl = document.createElement('div');
              slotEl.id = slotId;
              slotEl.className = 'overlay-slot';
              container.appendChild(slotEl);
            }
            slotEl.innerHTML = entry.html || '';
            _execScripts(slotEl);
            if (entry.css) {
              const styleId = 'slot-style-' + slotName;
              let styleEl = document.getElementById(styleId);
              if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = styleId;
                document.head.appendChild(styleEl);
              }
              styleEl.textContent = entry.css;
            }
          }
        }
      } catch (e) {
        console.log('No saved slots to restore');
      }
    }

    // --- 起動 ---
    initSprite();
    restoreDynamicContent();
    connectSSE();
  </script>
</body>

</html>