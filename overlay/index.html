<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      background-color: rgba(0, 0, 0, 0) !important;
      background: transparent !important;
      overflow: hidden;
      font-family: 'M PLUS Rounded 1c', 'Noto Sans JP', 'Yu Gothic UI', sans-serif;
    }

    #character {
      position: fixed;
      bottom: 0;
      right: 0;
      height: 50vh;
    }

    #character img {
      position: absolute;
      bottom: 0;
      right: 0;
      height: 100%;
      width: auto;
    }

    #subtitle {
      position: fixed;
      bottom: 5vh;
      right: 12vw;
      max-width: 35vw;
      padding: 12px 28px;
      background: rgba(0, 0, 0, 0.7);
      color: #7eeda9;
      font-size: clamp(14px, 1.3vw, 30px);
      font-weight: bold;
      border-radius: 12px;
      text-align: left;
      opacity: 0;
      transition: opacity 0.3s ease;
      text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8);
      line-height: 1.4;
      z-index: 10;
    }

    #subtitle.visible {
      opacity: 1;
    }

    #name {
      color: #ffd700;
      font-size: clamp(16px, 1.5vw, 34px);
      margin-bottom: 2px;
    }

    #status {
      position: fixed;
      top: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 12px;
      z-index: 20;
    }

    #activity {
      position: fixed;
      bottom: 52vh;
      right: 5vw;
      padding: 6px 14px;
      background: rgba(0, 0, 0, 0.6);
      color: #7eeda9;
      font-size: clamp(10px, 0.9vw, 16px);
      border-radius: 8px;
      border-left: 3px solid #7eeda9;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 18;
      white-space: nowrap;
    }

    #activity.visible {
      opacity: 1;
    }

    #activity .dot {
      display: inline-block;
      animation: blink 1.4s infinite;
    }

    #activity .dot:nth-child(2) { animation-delay: 0.2s; }
    #activity .dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes blink {
      0%, 20% { opacity: 0; }
      50% { opacity: 1; }
      100% { opacity: 0; }
    }

    #dynamic-content {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 16;
    }

    #dynamic-content > * {
      pointer-events: auto;
    }
  </style>
</head>

<body>
  <div id="character">
    <img id="sprite-base" src="sprites/base.png" alt="">
    <img id="sprite-mouth" src="sprites/mouth_closed.png" alt="">
  </div>
  <div id="subtitle">
    <div id="text"></div>
  </div>
  <div id="dynamic-content"></div>
  <div id="activity"></div>
  <div id="status">Loading...</div>

  <script>
    const subtitleEl = document.getElementById('subtitle');
    const textEl = document.getElementById('text');
    const statusEl = document.getElementById('status');
    const mouthImg = document.getElementById('sprite-mouth');
    let hideTimer = null;
    let audioCtx = null;

    const MOUTH_OPEN_SRC = 'sprites/mouth_open.png';
    const MOUTH_HO_SRC = 'sprites/mouth_ho.png';
    const MOUTH_O_SRC = 'sprites/mouth_o.png';
    const MOUTH_CLOSED_SRC = 'sprites/mouth_closed.png';
    const MOUTH_CYCLE = [MOUTH_CLOSED_SRC, MOUTH_HO_SRC, MOUTH_O_SRC, MOUTH_OPEN_SRC];

    // 画像プリロード
    new Image().src = MOUTH_OPEN_SRC;
    new Image().src = MOUTH_HO_SRC;
    new Image().src = MOUTH_O_SRC;
    new Image().src = MOUTH_CLOSED_SRC;

    // --- スプライト初期化 ---
    function initSprite() {
      const baseImg = document.getElementById('sprite-base');
      if (baseImg.complete && baseImg.naturalWidth > 0) {
        statusEl.textContent = 'Sprite OK';
      } else {
        baseImg.onload = () => { statusEl.textContent = 'Sprite OK'; };
        baseImg.onerror = () => { statusEl.textContent = 'Sprite: image not found'; };
      }
    }

    // --- 口パク (タイマーベースで3段階サイクル) ---
    let lipSyncTimer = null;
    let mouthFrame = 0;

    function startLipSync(durationSec) {
      stopLipSync();
      mouthFrame = 0;
      function nextFrame() {
        // ランダムに口の形を選ぶ (ただし同じ形が連続しにくくする)
        let next;
        do {
          next = Math.floor(Math.random() * MOUTH_CYCLE.length);
        } while (next === mouthFrame && MOUTH_CYCLE.length > 1);
        mouthFrame = next;
        mouthImg.src = MOUTH_CYCLE[mouthFrame];
        const delay = 80 + Math.random() * 120;
        lipSyncTimer = setTimeout(nextFrame, delay);
      }
      nextFrame();
      // 音声の長さ分で自動停止
      if (durationSec > 0) {
        setTimeout(() => stopLipSync(), durationSec * 1000);
      }
    }

    function stopLipSync() {
      if (lipSyncTimer) {
        clearTimeout(lipSyncTimer);
        lipSyncTimer = null;
      }
      mouthFrame = 0;
      mouthImg.src = MOUTH_CLOSED_SRC;
    }

    async function doLipSync(audioUrl) {
      try {
        const res = await fetch(audioUrl);
        const buf = await res.arrayBuffer();
        // WAVヘッダーからサンプルレートとデータサイズを取得して再生時間を計算
        const view = new DataView(buf);
        const sampleRate = view.getUint32(24, true);
        const dataSize = view.getUint32(40, true);
        const channels = view.getUint16(22, true);
        const bitsPerSample = view.getUint16(34, true);
        const duration = dataSize / (sampleRate * channels * (bitsPerSample / 8));
        startLipSync(duration);
      } catch (e) {
        // フォールバック: 3秒間口パク
        console.warn('Lip sync audio fetch failed, using fallback:', e);
        startLipSync(3);
      }
    }

    // --- SSE 接続 (字幕 + 口パク) ---
    function connectSSE() {
      const es = new EventSource('/overlay/events');

      es.addEventListener('subtitle', (e) => {
        try {
          const data = JSON.parse(e.data);
          const text = data.text || '';
          if (text) {
            textEl.textContent = text;
            subtitleEl.classList.add('visible');
            clearTimeout(hideTimer);
          } else {
            hideTimer = setTimeout(() => subtitleEl.classList.remove('visible'), 500);
          }
        } catch (err) {
          if (e.data) {
            textEl.textContent = e.data;
            subtitleEl.classList.add('visible');
            clearTimeout(hideTimer);
          }
        }
      });

      es.addEventListener('speak', (e) => {
        const data = JSON.parse(e.data);
        if (data.audioUrl) {
          doLipSync(data.audioUrl);
        }
      });

      es.addEventListener('activity', (e) => {
        const data = JSON.parse(e.data);
        const activityEl = document.getElementById('activity');
        const text = data.text || '';
        if (text) {
          activityEl.innerHTML = text + ' <span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>';
          activityEl.classList.add('visible');
        } else {
          activityEl.classList.remove('visible');
        }
      });

      es.addEventListener('html', (e) => {
        const data = JSON.parse(e.data);
        const container = document.getElementById('dynamic-content');
        if (data.html !== undefined) {
          container.innerHTML = data.html;
          // innerHTML ではscriptタグが実行されないため、明示的に再挿入する
          container.querySelectorAll('script').forEach(oldScript => {
            const newScript = document.createElement('script');
            for (const attr of oldScript.attributes) {
              newScript.setAttribute(attr.name, attr.value);
            }
            newScript.textContent = oldScript.textContent;
            oldScript.parentNode.replaceChild(newScript, oldScript);
          });
        }
        if (data.css) {
          let styleEl = document.getElementById('dynamic-style');
          if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'dynamic-style';
            document.head.appendChild(styleEl);
          }
          styleEl.textContent = data.css;
        }
      });

      es.onerror = () => {
        es.close();
        statusEl.textContent = 'Reconnecting...';
        setTimeout(connectSSE, 2000);
      };

      es.onopen = () => {
        statusEl.textContent = 'Sprite OK';
      };
    }

    // --- 保存済み動的コンテンツの復元 ---
    async function restoreDynamicContent() {
      try {
        const resp = await fetch('/overlay/dynamic-state.json?' + Date.now());
        if (resp.ok) {
          const data = await resp.json();
          const container = document.getElementById('dynamic-content');
          if (data.html) {
            container.innerHTML = data.html;
            container.querySelectorAll('script').forEach(oldScript => {
              const newScript = document.createElement('script');
              for (const attr of oldScript.attributes) {
                newScript.setAttribute(attr.name, attr.value);
              }
              newScript.textContent = oldScript.textContent;
              oldScript.parentNode.replaceChild(newScript, oldScript);
            });
          }
          if (data.css) {
            let styleEl = document.getElementById('dynamic-style');
            if (!styleEl) {
              styleEl = document.createElement('style');
              styleEl.id = 'dynamic-style';
              document.head.appendChild(styleEl);
            }
            styleEl.textContent = data.css;
          }
        }
      } catch (e) {
        console.log('No saved dynamic content to restore');
      }
    }

    // --- 起動 ---
    initSprite();
    restoreDynamicContent();
    connectSSE();
  </script>
</body>

</html>